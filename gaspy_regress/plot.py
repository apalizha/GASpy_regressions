'''
This module contains functions to create plots from the data generated by GASpy
and the regressions created by GASpy_regressions.

Note that many of the plots require Excel files of input data. The formatting
of the Excel files is important. You should follow the templates in the repo.
'''

__author__ = 'Kevin Tran'
__email__ = 'ktran@andrew.cmu.edu'

import pdb  # noqa: F401
import warnings
import numpy as np
from plotly.offline import init_notebook_mode, iplot
import plotly.graph_objs as go
import matplotlib
from matplotlib import pyplot as plt
import seaborn as sns
from .transform import _pull_literature_volcano


def volcano(data, excel_file_path, sheetname, scale='linear', title=None,
            x_label='adsorption energy (eV)', y_label='activity', jupyter=True):
    '''
    '''
    # Unpack the data structure
    sim_data, unsim_data = data
    ads_docs, ads_data, _ = zip(*sim_data)
    cat_docs, cat_data = zip(*unsim_data)
    ads_x_data, ads_y_data = zip(*ads_data)
    cat_x_data, cat_y_data = zip(*cat_data)
    ads_x, ads_x_u = zip(*ads_x_data)
    cat_x, cat_x_u = zip(*cat_x_data)
    ads_y, ads_y_u = zip(*ads_y_data)
    cat_y, cat_y_u = zip(*cat_y_data)

    # Load the experimental data points from the volcano
    _, x_expt, y_expt, labels_expt = _pull_literature_volcano(excel_file_path, sheetname, scale=scale)

    # Create plotly traces for the experimental data points, the regressor's estimations,
    # and then (if necessary) the results from the database
    traces = [go.Scatter(x=x_expt, y=y_expt, name='Experimental Points',
                         mode='markers', text=labels_expt),
              _make_trace(cat_x, cat_y, cat_docs, name='Regressor Estimations'),
              _make_trace(ads_x, ads_y, ads_docs, name='Simulation Predictions')]

    # Format and display
    y_axis = dict(title=y_label)
    if scale == 'log':
        y_axis['type'] = 'log'
    layout = go.Layout(xaxis=dict(title=x_label), yaxis=y_axis, title=dict(title=title))
    if jupyter:
        init_notebook_mode(connected=True)
    iplot(go.Figure(data=traces, layout=layout))


def filtered_parity(data, transform=True, scale='linear', plot_type='hex', title=None,
                    x_label='DFT-prediction', y_label='ML-estimate', plot_range=None,
                    color='k', font_size=15, font_scale=1, grid_size=20, marker_size=20,
                    jupyter=True,
                    save=False, save_name='transformed_parity.pdf', save_dpi=900, **kwargs):
    '''
    This function will create a parity plot of a regression, but instead of plotting the typical
    "estimate vs. truth", it will plot a transformed version of "estimate vs. truth". For example,
    it can turn an adsorption energy parity plot into an activity parity plot.

    Note that we used the suffixes `pred` and `est`. `pred` corresponds to simulation predictions,
    and `est` corresponds to surrogame model estimates.

    Inputs:
        plot_type   A string indicating the type of parity plot you want. This can be:
                    hex         For a seaborn hex plot
                    matplotlib  For a matplotlib scatter plot
                    plotly      For a plotly scatter plot
        transform   A boolean indicating whether you want to plot the transformed data or not.
        scale       A string indicating the scale of the thing you want to plot. Can be
                    'linear' or 'log'
        title       Title of the plot
        x_label     X-axis label of the plot
        y_label     Y-axis label of the plot
        plot_range  A list whose first element is the minimum axis value to plot and whose
                    second element is the maximum axis value to plot
        color       The color you want to plot with. Only works with
                    plot_type == 'matplotlib' or 'hex'
        font_size   The size of the fonts you want to create. Does nothing when
                    plot_type == 'plotly'
        font_scale  Scale the font. Works only when plot_type == 'hex'
        marker_size The size of the markers. Works only when plot_type == 'matplotlib'
        jupyter     A boolean indicating whether or not you're using jupyter. This is
                    really only necessary when plot_type == 'plotly'
        save        A boolean indicating whether or not you want to save the plot.
        save_name   A string for the name of the file you want to save to. Only works when
                    save == True
        save_dpi    An integer indicating what DPI you want to use. Only works when
                    save == True
    '''
    # Unpack the data structure
    sim_data, _ = data
    docs, predictions, estimations = zip(*sim_data)
    x_data_pred, y_data_pred = zip(*predictions)
    x_data_est, y_data_est = zip(*estimations)
    # If we want to plot the transformed data, then we pull out the y-values
    if transform:
        pred, pred_u = zip(*y_data_pred)
        est, est_u = zip(*y_data_est)
        pred = np.array(pred)
        est = np.array(est)
    # If we want to plot the untransformed data, then we pull out the x-values
    else:
        pred, pred_u = zip(*x_data_pred)
        est, est_u = zip(*x_data_est)
        pred = np.array(pred)
        est = np.array(est)
    # Calculate the range of the data and set `plot_range` if it's not specified
    if not plot_range:
        plot_min = np.min(np.minimum(pred, est))
        plot_max = np.max(np.maximum(pred, est))
        plot_range = [plot_min, plot_max]
    else:
        plot_min = plot_range[0]
        plot_max = plot_range[1]

    # Make a hex plot with Seaborn
    if plot_type == 'hex':
        # Scaling/font sizes
        sns.set_context('paper', rc={'font.size': font_size,
                                     'axes.titlesize': font_size,
                                     'axes.labelsize': font_size})
        sns.set(font_scale=font_scale)
        if scale == 'linear':
            pass
        elif scale == 'log':
            # Seaborn is not yet good at making log-log jointplots with hexbin shading.
            # So we make a linear jointplot with hexbin shading, but simply put the logarithm
            # of the values in.
            plot_range = tuple(np.log10(plot_range))
            plot_min = np.log10(plot_min)
            plot_max = np.log10(plot_max)
            pred = np.log10(pred)
            est = np.log10(est)
        else:
            raise ValueError('That scale type is not recognized')
        # Note that we also trim out points outside of the plotting range,
        # because the hex bins get all messed up if we simply "zoom in". We also convert to
        # numpy arrays because Seaborn likes them.
        pred_trimmed = []
        est_trimmed = []
        for _pred, _est in zip(pred, est):
            if plot_min < _pred < plot_max and plot_min < _est < plot_max:
                pred_trimmed.append(_pred)
                est_trimmed.append(_est)
        pred_trimmed = np.array(pred_trimmed)
        est_trimmed = np.array(est_trimmed)
        # Now plot
        g = sns.jointplot(pred_trimmed, est_trimmed, kind='hex', space=0, stat_func=None,
                          gridsize=grid_size, color=color)
        g.set_axis_labels(x_label, y_label)
        plt.tight_layout()
        # Save & display
        if save:
            plt.savefig(save_name, bbox_inches='tight', dpi=save_dpi)
        plt.show()

    # Make a scatter plot with Matplotlib
    if plot_type == 'matplotlib':
        plt.scatter(pred, est, s=marker_size, c=color)
        plt.xlim(plot_min, plot_max)
        plt.ylim(plot_min, plot_max)
        if scale == 'log':
            ax = plt.gca()
            ax.set_xscale(scale)
            ax.set_yscale(scale)
        elif scale == 'linear':
            pass
        else:
            raise ValueError('That scale type is not recognized')
        font = {'size': font_size}
        matplotlib.rc('font', **font)
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        # Save & display
        if save:
            plt.savefig(save_name, bbox_inches='tight', dpi=save_dpi)
        plt.show()

    # Make a scatter plot with Plotly
    if plot_type == 'plotly':
        traces = [_make_trace(pred, est, docs, name='Simulations'),
                  go.Scatter(x=plot_range, y=plot_range, name='Parity',
                             line=dict(color=('black'), dash='dash'))]
        xaxis = dict(title=x_label, range=plot_range)
        yaxis = dict(title=y_label, range=plot_range)
        if scale == 'log':
            plot_range = np.log10(plot_range)
            xaxis['range'] = plot_range
            yaxis['range'] = plot_range
            xaxis['type'] = 'log'
            yaxis['type'] = 'log'
        elif scale == 'linear':
            pass
        else:
            raise ValueError('That scale type is not recognized')
        layout = go.Layout(xaxis=xaxis, yaxis=yaxis, title=title,
                           width=800, height=800, legend=dict(x=0, y=1))
        if jupyter:
            init_notebook_mode(connected=True)
        # Save & display
        if save:
            warnings.warn('Not saving a figure when you choose to use plotly. Export it yourself.')
        iplot(go.Figure(data=traces, layout=layout))


def _make_trace(x, y, docs, name):
    '''
    This function creates a plotly "trace"

    Inputs:
        x       A sequence for the y-values that you want to plot
        y       A sequence for the y-values that you want to plot
        docs    The corresponding "mongo documents" that go with `x`.
                Refer to `gaspy.utils.get_docs` for more details.
        name    A string indicating how you want this trace to be... named
    Output
        trace   A plotly graph object that you can add to a list of traces
    '''
    # Concatenate the parsed mongo documents into strings to include as hovertext
    hover_text = []
    for doc in docs:
        text = ''
        for fingerprint, fp_value in doc.iteritems():
            text += '<br>' + str(fingerprint) + ':  ' + str(fp_value)
        hover_text.append(text)

    # Add the catalog data to the plot
    trace = go.Scatter(x=x, y=y, name=name,
                       mode='markers', text=hover_text)

    return trace
